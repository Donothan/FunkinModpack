import funkin.modding.module.Module;
import funkin.graphics.adobeanimate.FlxAtlasSprite;
import funkin.graphics.FunkinSprite;
import funkin.modding.base.ScriptedFlxAtlasSprite;
import funkin.play.PlayState;
import funkin.play.notes.Strumline;
import funkin.play.notes.notekind.NoteKind;
import flixel.FlxG;
import Std;
import funkin.audio.FunkinSound;
import flixel.util.FlxTimer;
import flixel.util.FlxTimerManager;

class OpponentBadSingingModule extends Module
{

	var missChance:int = .10;
	var shouldMiss:bool = true;
	var canMiss:bool = true;


	function new()
	{
		super('OpponentBadSinging');

	}

	function onSongStart(event:ScriptEvent):Void 
	{
		super.onSongStart(event);

			switch (PlayState.instance.currentDifficulty)
			{
			case 'easy':
				missChance = .45*FlxG.random.float(.5, 2);
			case 'normal':
				missChance = .30*FlxG.random.float(.5, 2);
			case 'hard':
				missChance = .20*FlxG.random.float(.5, 1.5);
			case 'erect':
				missChance = .12*FlxG.random.float(.5, 1.25);
			case 'nightmare':
				missChance = .05*FlxG.random.float(.5, 1.5);
			}
	}

	function onUpdate(event:ScriptEvent):Void
		{
			super.onUpdate(event);

			if (canMiss && missChance >= FlxG.random.float(0, 1))
				{
				shouldMiss = true;
				}
			else
				{
				shouldMiss = false;
				}
		}


	function onNoteHit(event:HitNoteScriptEvent)
		{
			super.onNoteHit(event);

		PlayState.instance.vocals.opponentVolume = 1;

		 if (PlayState.instance.currentStage == null) return;
			if (!event.note.noteData.getMustHitNote() && shouldMiss == true) {

				event.cancelEvent();
				PlayState.instance.vocals.opponentVolume = 0;
				PlayState.instance.applyScore(0, '', .0025, false);
				FunkinSound.playOnce(Paths.soundRandom('missnote', 1, 3), FlxG.random.float(0.1, 0.25));
				canMiss = false;
				shouldMiss = false;
					new FlxTimer().start(3, function(tmr)
					{
						canMiss = true;
					});
		}

	}


}